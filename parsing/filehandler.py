# Written by RedFantom, Wing Commander of Thranta Squadron,
# Daethyra, Squadron Leader of Thranta Squadron and Sprigellania, Ace of Thranta Squadron
# Thranta Squadron GSF CombatLog Parser, Copyright (C) 2016 by RedFantom, Daethyra and Sprigellania
# All additions are under the copyright of their respective authors
# For license see LICENSE

# Own modules
from tools.utilities import get_temp_directory
# General imports
import pickle as pickle
import os
from datetime import datetime
import operator


class FileHandler(object):
    """
    Reads the files generated by ScreenParser for file parsing
    """

    @staticmethod
    def get_dictionary_key(dictionary, timing, value=False):
        if not isinstance(dictionary, dict):
            raise ValueError()
        if not isinstance(timing, datetime):
            raise ValueError()
        for key, val in dictionary.items():
            if not isinstance(key, datetime):
                continue
            if key == timing:
                if value:
                    return val
                return key
        return None

    @staticmethod
    def get_dictionary_key_secondsless(dictionary, timing):
        # The match_dt as received is not found in the dictionary, so further searching is required
        # First, searching starts by removing the seconds from the match_dt
        timing_secondsless = timing.replace(second=0, microsecond=0)
        # Now we build a dictionary that also has secondsless keys
        dictionary_secondsless_keys = \
            {key.replace(second=0, microsecond=0): value for key, value in dictionary.items()}
        # Now we attempt to match the secondsless key in the secondsless file_dict
        correct_key = FileHandler.get_dictionary_key(dictionary_secondsless_keys, timing_secondsless)
        if correct_key:
            # We have found the correct key for the match
            return correct_key
        return None

    @staticmethod
    def get_spawn_dictionary(data, file_name, match_dt, spawn_dt):
        """
        Function to get the data dictionary for a spawn based on a file name, match datetime and spawn datetime. Uses
        a lot of code to make the searching as reliable as possible.
        """
        print("Spawn data requested for:\n{}\n{}\n{}".format(file_name, match_dt, spawn_dt))
        # First check if the file_name is available
        if file_name not in data:
            return "Not available for this file.\n\nScreen parsing results are only available for spawns in files " \
                   "which were spawned while screen parsing was enabled and real-time parsing was running."
        try:
            file_dt = datetime.strptime(file_name[:-10], "combat_%Y-%m-%d_%H_%M_%S_")
        except ValueError:
            return "Not available for this file.\n\nScreen parsing results are not supported for file names which do " \
                   "not match the original Star Wars - The Old Republic CombatLog file name format."
        file_dict = data[file_name]
        # Next up comes the checking of datetimes, which is slightly more complicated due to the fact that even equal
        # datetime objects with the == operators, are not equal with the 'is' operator
        # Also, for backwards compatibility, different datetimes must be supported in this searching process
        # Datetimes always have a correct time, but the date is not always the same as the filename date
        # If this is the case, the date is actually set to January 1 1900, the datetime default
        # Otherwise the file name of the CombatLog must have been altered
        match_dict = None
        for key, value in file_dict.items():
            if key.hour == match_dt.hour and key.minute == match_dt.minute:
                match_dict = value
        if match_dict is None:
            return "Not available for this match\n\nScreen parsing results are only available for spawns " \
                   "in matches which were spawned while screen parsing was enabled and real-time parsing " \
                   "was running"
        # Now a similar process starts for the spawns, except that seconds matter here.
        spawn_dict = None
        for key, value in match_dict.items():
            if key is None:
                # If the key is None, something weird is going on, but we do not want to throw any data away
                # This may be caused by a bug in the ScreenParser
                # For now, we reset key to a sensible value, specifically the first moment the data was recorded, if
                # that's possible. If not, we'll skip it.
                try:
                    key = list(value[list(value.keys())[0]].keys())[0]
                except (KeyError, ValueError, IndexError):
                    continue
            if key.hour == spawn_dt.hour and key.minute == spawn_dt.minute and key.second == spawn_dt.second:
                spawn_dict = value
        if spawn_dict is None:
            return "Not available for this spawn\n\nScreen parsing results are not available for spawns which " \
                   "were not  spawned while screen parsing was enabled and real-time parsing were running."
        print("Retrieved data: {}".format(spawn_dict))
        return spawn_dict

    @staticmethod
    def get_data_dictionary(name="realtime.db"):
        with open(os.path.join(get_temp_directory(), name), "rb") as fi:
            data = pickle.load(fi)
        return data

    @staticmethod
    def get_spawn_stats(file_name, match_dt, spawn_dt):
        """
        Function to return the spawn statistics
        :param file_name:
        :param match_dt:
        :param spawn_dt:
        :return:
        """
        data = FileHandler.get_data_dictionary()
        value = FileHandler.get_spawn_dictionary(data, file_name, match_dt, spawn_dt)
        if isinstance(value, str):
            return value
        elif isinstance(value, dict):
            spawn_dicts = value
        else:
            raise ValueError("Returned value from get_spawn_dictionary is neither str nor dict")
        # Start calculations on this spawn data
        power_mgmt = {1: 0, 2: 0, 3: 0, 4: 0}
        for key, value in spawn_dicts["power_mgmt"].items():
            if not value:
                continue
            power_mgmt[value] += 1
        power_mgmt_max = max(power_mgmt.items(), key=operator.itemgetter(1))[0]
        tracking = 0
        amount = 0
        for key, value in spawn_dicts["tracking"].items():
            if not value:
                continue
            tracking += value
            amount += 1
        if amount == 0:
            tracking = "Not available for this spawn"
        else:
            tracking = tracking / amount
        total = (0, 0, 0)
        for key, value in spawn_dicts["health"].items():
            if not value:
                break
            total += value
        try:
            average_health = tuple(key / len(spawn_dicts["health"]) for key in total)
        except (ZeroDivisionError, TypeError):
            average_health = "Not available for this spawn"
        return FileHandler.get_formatted_stats_string(*(power_mgmt_max, tracking, average_health))

    @staticmethod
    def get_formatted_stats_string(*values):
        return """
        Most used power management: \t{0}
        Average tracking degrees: \t\t{1:.2f}
        Average ship health: \t\t{2}
        """.format(*values)
